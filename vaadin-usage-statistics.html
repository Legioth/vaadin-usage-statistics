<link rel="import" href="../vaadin-development-mode-detector/vaadin-development-mode-detector.html">

<!-- Gathers usage statistics for Vaadin Elements when application is run in development mode (on localhost) -->
<!-- No statistics will be gathered when running in production -->
<!-- -->
<!-- To opt out from statistics, run the following command in the browser console when your app is open: -->
<!-- localStorage.setItem("vaadin.statistics.optout","true"); -->

<script>
{
  const isDebug = function() {
    return localStorage.getItem("vaadin.statistics.debug");
  }
  const debug = function(msg) {
    if (isDebug()) {
      console.log("vaadin-usage-statistics: "+msg);
    }
  };

  const usageStatisticsVersion = "0.0.1";
  const reportingInterval = 1000*60*60*24;
  const now = new Date().getTime();
  const firstPingKey = "vaadin.statistics.firstping";
  const lastPingKey = "vaadin.statistics.lastping";
  const optOutKey = "vaadin.statistics.optout";
  const statsStorageKey = "vaadin.statistics.basket";
  const gatherDelay = 10000; // Delay between loading this file and gathering stats
  const url = "https://tools.vaadin.com/usage-stats/submit"

  const frameworkVersionDetectors = {
    'Flow': function() {
      if (window.vaadin && window.vaadin.clients) {
        var flowVersions = Object.values(window.vaadin.clients)
        .filter(client => client.getVersionInfo)
        .map(client => client.getVersionInfo().flow);
        if (flowVersions.length > 0) {
          return flowVersions[0];
        }
      }
    },
    'Vaadin Framework': function() {
      if (window.vaadin && window.vaadin.clients) {
        var frameworkVersions = Object.values(window.vaadin.clients)
          .filter(client => client.getVersionInfo)
          .map(client => client.getVersionInfo().vaadinVersion);
        if (frameworkVersions.length > 0) {
          return frameworkVersions[0];
        }
      }
    },
    'AngularJs': function() {
      if (window.angular && window.angular.version && window.angular.version) {
        return window.angular.version.full;
      }
    },
    'Angular': function() {
      if (window.ng) {
        const tags = document.querySelectorAll("[ng-version]");
        if (tags.length > 0) {
          return tags[0].getAttribute("ng-version");
        }
        return "Unknown";
      }
    },
    'Backbone.js': function() {
      if (window.Backbone) {
        return window.Backbone.VERSION;
      }
    },
    'React': function() {
      var reactSelector = '[data-reactroot], [data-reactid]';
      if (!!document.querySelector(reactSelector)) {
        // React does not publish the version by default
        return "unknown";
      }
    },
    'Ember': function() {
      if (window.Em && window.Em.VERSION) {
        return window.Em.VERSION;
      } else if (window.Ember && window.Ember.VERSION) {
        return window.Ember.VERSION;
      }
    },
    'jQuery': function() {
      if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
        return jQuery.prototype.jquery;
      }
    },
    'Polymer': function() {
      if (window.Polymer && window.Polymer.version) {
        return window.Polymer.version;
      }
    },
    'Vue.js': function() {
      if (window.Vue) {
        return window.Vue.version;
      }
    }
  };
  // Wait until the application has been running for a while to see which elements are used
  const getUsedVaadinElements = function(elements) {
    const elementClasses = Object.keys(window.Vaadin).map(c => window.Vaadin[c]).filter(c=>c.is);
    elementClasses.forEach(cls => {
      const version = cls.version ? cls.version : "0.0.0";
      elements[cls.is]=version;
    });
  }
  const getFrameworks = function(frameworks) {
    Object.keys(frameworkVersionDetectors).forEach(framework => {
      const detector = frameworkVersionDetectors[framework];
      try {
        const version = detector();
        if (version) {
          frameworks[framework] = version;
        }
      } catch (e) {
      }
    });
  };

  const gatherStats = function() {
    const storedStatsString = localStorage.getItem(statsStorageKey);
    const storedStats = JSON.parse(storedStatsString ? storedStatsString : "{}");

    var gatheredStats = {elements: {}, frameworks: {}};
    getUsedVaadinElements(gatheredStats.elements);
    getFrameworks(gatheredStats.frameworks);

    Object.assign(gatheredStats.elements, storedStats.elements);
    Object.assign(gatheredStats.frameworks, storedStats.frameworks);
    localStorage.setItem(statsStorageKey, JSON.stringify(gatheredStats));
    if (JSON.stringify(gatheredStats) != JSON.stringify(storedStats) && Object.keys(gatheredStats).length > 0) {
      debug("New stats: " + JSON.stringify(gatheredStats));
    }

    return gatheredStats;
  };

  const sendData = function(url, data) {
    debug("Sending data to " + url);
    var req = new XMLHttpRequest();
    req.withCredentials = true;
    req.addEventListener("readystatechange", function() {
      if(req.readyState === XMLHttpRequest.DONE && req.status === 200) {
        debug("Response: " + req.responseText);
      }
    });
    req.addEventListener("error", function() {
      debug("Send failed :(");
    });
    req.open("POST", url);
    req.setRequestHeader("Content-Type", "application/json");

    req.send(JSON.stringify(data));

  }

  const triggerSending = function() {
    setTimeout(() => {
      const firstPing = Number(localStorage.getItem(firstPingKey));
      const lastPing = Number(localStorage.getItem(lastPingKey));

      if (!firstPing) {
        // Use a grace period to avoid interfering with tests, incognito mode etc
        localStorage.setItem(firstPingKey, now);
        localStorage.setItem(lastPingKey, now);
        debug("First invocation. The first ping will not take place until " + reportingInterval + "ms has passed");
        return;
      }

      if (now < (lastPing + reportingInterval) ) {
        // debug("Pinged recently. The next ping will not take place until " + (reportingInterval-(now-lastPing)) + "ms has passed");
        return;
      }

      const versions = gatherStats();
      const nrElements = Object.keys(versions.elements).length;
      const nrFrameworks = Object.keys(versions.frameworks).length;

      localStorage.setItem(lastPingKey, new Date().getTime());
      localStorage.removeItem(statsStorageKey);
      if ((nrElements + nrFrameworks) == 0) {
        // No relevant products in use, ignore
        return;
      }

      var data = versions;
      data["firstPing"] = firstPing;
      data["usageStatisticsVersion"] = usageStatisticsVersion;
      sendData(url, data);
    }, gatherDelay);
  }

  window.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};
  window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
    if (localStorage.getItem(optOutKey)) {
      return;
    }
    gatherStats();
    triggerSending();
  };
}
</script>
