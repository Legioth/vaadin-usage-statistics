<link rel="import" href="../vaadin-development-mode-detector/vaadin-development-mode-detector.html">

<script>
const frameworkVersionDetectors = {
  'Flow': function() {
    if (window.vaadin && window.vaadin.clients) {
      var flowVersions = Object.values(window.vaadin.clients)
      .filter(client => client.getVersionInfo)
      .map(client => client.getVersionInfo().flow);
      if (flowVersions.length > 0) {
        return flowVersions[0];
      }
    }
  },
  'Vaadin Framework': function() {
    if (window.vaadin && window.vaadin.clients) {
      var frameworkVersions = Object.values(window.vaadin.clients)
        .filter(client => client.getVersionInfo)
        .map(client => client.getVersionInfo().vaadinVersion);
      if (frameworkVersions.length > 0) {
        return frameworkVersions[0];
      }
    }
  },
  'AngularJs': function() {
    if (window.angular && window.angular.version && window.angular.version) {
      return window.angular.version.full;
    }
  },
  'Angular': function() {
    if (window.ng) {
      const tags = document.querySelectorAll("[ng-version]");
      if (tags.length > 0) {
        return tags[0].getAttribute("ng-version");
      }
      return "Unknown";
    }
  },
  'Backbone.js': function() {
    if (window.Backbone) {
      return window.Backbone.VERSION;
    }
  },
  'React': function() {
    var reactSelector = '[data-reactroot], [data-reactid]';
    if (!!document.querySelector(reactSelector)) {
      // React does not publish the version by default
      return "unknown";
    }
  },
  'Ember': function() {
    if (window.Em && window.Em.VERSION) {
      return window.Em.VERSION;
    } else if (window.Ember && window.Ember.VERSION) {
      return window.Ember.VERSION;
    }
  },
  'jQuery': function() {
    if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
      return jQuery.prototype.jquery;
    }
  },
  'Polymer': function() {
    if (window.Polymer && window.Polymer.version) {
      return window.Polymer.version;
    }
  },
  'Vue.js': function() {
    if (window.Vue) {
      return window.Vue.version;
    }
  }
};
// Wait until the application has been running for a while to see which elements are used
const getUsedVaadinElements = function(versions) {
  const elementClasses = Object.keys(window.Vaadin).map(c => window.Vaadin[c]).filter(c=>c.is);
  elementClasses.forEach(cls => {
    const version = cls.version ? cls.version : "0.0.0";
    versions.push({element: cls.is, version: version});
  });
}
const getFrameworks = function(versions) {
  Object.keys(frameworkVersionDetectors).forEach(framework => {
    const detector = frameworkVersionDetectors[framework];
    try {
      const version = detector();
      if (version) {
        versions.push({framework: framework, version: version});
      }
    } catch (e) {
    }
  });
};

const gatherStats = function() {
  var versions = [];
  getUsedVaadinElements(versions);
  getFrameworks(versions);
  return versions;
};

const sendData = function(url, data) {
  debug("Sending data to " + url);
  var req = new XMLHttpRequest();
  req.withCredentials = true;
  req.addEventListener("readystatechange", function() {
    if(req.readyState === XMLHttpRequest.DONE && req.status === 200) {
      debug("Response:\n\n" + req.responseText);
    }
  });
  req.addEventListener("error", function() {
    debug("Send failed :(");
  });
  req.open("POST", url);
  req.setRequestHeader("Content-Type", "application/json");

  req.send(JSON.stringify(data));

}

const debug = function(msg) {
  console.log("vaadin-usage-statistics: "+msg);
};

window.Vaadin.developmentModeCallback = window.Vaadin.developmentModeCallback || {};
window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
  const pingInterval = 5000; // 1000*60*60*24;
  const now = new Date().getTime();
  const firstPingKey = "vaadin.statistics.firstping";
  const lastPingKey = "vaadin.statistics.lastping";
  const gatherDelay = 5000; // Delay between loading this file and gathering stats. Should be 1 minute or so
  const url = "https://license-server-stg.int.vaadin.com:8443/mau/";

  setTimeout(() => {
    const firstPing = localStorage.getItem(firstPingKey);
    const lastPing = Number(localStorage.getItem(lastPingKey));

    if (!firstPing) {
      // Use a grace period to avoid interfering with tests, incognito mode etc
      localStorage.setItem(firstPingKey, now);
      localStorage.setItem(lastPingKey, now);
      debug("First invocation. The first ping will not take place until " + pingInterval + "ms has passed");
      return;
    }

    if (now < (lastPing + pingInterval) ) {
      // Pinged recently
      debug("Pinged recently. The next ping will not take place until " + (pingInterval-(now-lastPing)) + "ms has passed");
      return;
    }

    const versions = gatherStats();
    if (versions.length == 0) {
      // No relevant products in use, ignore
      return;
    }
    var data = {}
    data["versions"] = versions;
    data["firstPing"] = firstPing;
    localStorage.setItem(lastPingKey, new Date().getTime());
    sendData(url, data);
  }, gatherDelay);
  debug("Checking in "+gatherDelay+"ms");
};
</script>
